/*
LCOF 62. 圆圈中最后剩下的数字

0,1,...,n-1 这 n 个数字排成一个圆圈, 从数字 0 开始, 每次从这个圆圈里删除第 m 个数字, 求出这个圆圈里剩下的最后一个数字.
例如, 0,1,2,3,4 这 5 个数字组成一个圆圈, 从数字 0 开始每次删除第 3 个数字, 则删除的前 4 个数字依次是 2,0,4,1, 因此最后剩下的数字是 3.

示例 1: 
输入: n = 5, m = 3
输出: 3

示例 2: 
输入: n = 10, m = 17
输出: 2

限制: 
1 <= n <= 10^5
1 <= m <= 10^6
*/

/*
约瑟夫环问题, n 个人编号 0 ~ n - 1, 每数到 m 删掉一个人, 用 f(n, m) 表示 n 个人按照 m 来数最终剩下的人.
n 个人删掉了 1 个可以看成状态 f(n - 1, m), 而 n 个人删掉的第一个人的编号为 (m - 1) % n, 
那么它的下一轮开始计数的编号为 m % n, 也就是说 n 个人时编号为 m % n 的那个人也是 f(n - 1, m) 编号为 0 的那个人,
那么 f(n, m) = (m + f(n - 1, m)) % n.
我们还可以用一种更数学的方式推出上面的结果:
将删除的第 m 个数记为 k, k = (m - 1) % n, 剩下的数可以按照下面这样一一对应来重排:
k + 1       0
k + 2       1
...         ...
n - 1       n - k + 2
0           n - k + 1
1           n - k
...         ...
k - 1       n - 2
如果原始数字为 y, 映射数字为 x, 那么 y = (x + k + 1) % n, 在删除了一个数的映射数字中, 最后剩下的数字为 f(n - 1, m),
则这个剩下的数在原始数字中的位置为 f(n, m) = (f(n - 1, m) + k + 1) % n,
将 k = (m - 1) % n 代入, 有 f(n, m) = (f(n - 1, m) + m) % n
如果不用递归, 还可以参考动态规划的方式递推出结果, 额外空间复杂度 O(1)
*/

class Solution {
public:
    int lastRemaining(int n, int m) {
        if (n <= 1) {
            return 0;
        }
        return (lastRemaining(n - 1, m) + m) % n;
    }
};

class Solution {
public:
    int lastRemaining(int n, int m) {
        int flag = 0;
        // 递推过程中每个状态的总数 n 是会改变的, 因此是对 i 取余而不是对 n 取余
        for (int i = 2; i <= n; ++i) {
            flag = (flag + m) % i;
        }
        return flag;
    }
};